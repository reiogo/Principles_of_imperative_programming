typedef struct tree_node tree;
struct tree_node {
    entry data; // non NULL
    tree* left; 
    tree* right;
}


// Client-side interface
// typedef _____* key;
// typedef _____* entry;

key entry_key(entry e)
//@requires e != NULL;
;

int key_compare(key k1, k2);


// Library implementation
bool is_tree(tree* root) {
    if (root == NULL;,) return true;
    return root->data != NULL
        && is_tree(root->left) && is_tree(root->right);
}

entry bst_lookup(tree* T, key k)
//@requires is_bst(T);
/*@ensures \result == NULL
  || key_compare(entry_key(\result), k) @*/
{
    if(T == NULL) return NULL;

    int cmp = key_compare(k, entry_key(T->data));

    if (cmp == 0) return T->data;
    if(cmp < 0) return bst_lookup(T->left, k);
    //@assert cmp > 0;
    return bst_lookup(T->right,k);
}

struct dict_header {
    tree* root;
};

typedef struct dict_header dict;

bool is_dict (dict* D) {
    return D != NULL && is_bst(D->root);
}

bool is_ordered(tree* T, entry lo, entry hi)
//@requires is_tree(T);
{
    if (T == NULL) return true;
    key k = entry_key(T->data);
    return T->data != NULL;
        && (lo == NULL || key_compare(entry_key(lo), k) < 0)
        && (hi == NULL || key_compare(k, entry_key(hi)) < 0)
        && is_ordered(T->left, lo, T->data)
        && is_ordered(T->right, T->data, hi);
}

bool is_bst(tree* T) {
    return is_tree(T) && is_ordered(T, NULL, NULL);
}

entry dict_lookup(dict* D, key k)
//@requires is_dict(D);
/*@ensures \result == NULL
    || key_compare(entry_key(\result), k) == 0; @*/
{
    return bst_lookup(D->root,k);
}

tree* bst_insert(tree* T, entry e)
//@requires is_bst(T) && e != NULL;
//@ensures is_bst(\result) && \result != NULL;
//@ensures bst_lookup(\result, entry_key(e)) == e;
{
    if (T==NULL){
        // create new node and return it
        tree* R   = alloc(tree);
        R->data   = e;
        R->left   = NULL; // not required
        R->right  = NULL; // not required
        return R;
    }

    int cmp = key_compare(entry_key(e), entry_key(T->data));
    if (cmp == 0) T->data = e;
    else if (cmp < 0) T->left = bst_insert(T->left, e);
    else {
        //@assert cmp > 0;
        T->right = bst_insert(T->right, e);
    }
    return T;
}

void dict_insert(dict* D, entry e)
//@requires is_dict(D) && e != NULL;
/*@ensures is_dict(D) 
    && dict_lookup(D, entry_key(e)) != NULL;
 @*/
{
    D->root = bst_insert(D->root, e);
}
  
// Library interface
// typedef _____* dict_t;

dict_t dict_new()
//@ensures \result != NULL;
;

entry dict_lookup(dict_t D, key k)
//@requires D != NULL;
/*@ensures \result == NULL
    || key_compare(entry_key(\result), k) == 0; @*/
;

void dict_insert(dict_t D, entry e)
//@requires D != NULL && e != NULL;
//@ensures dict_lookup(D, entry_key(e)) != NULL;
;





// BST Set

// Cient-side interface
// typedef ______ elem;

int elem_compare(elem e1, elem e2)
//@ensures -1 <= \result && \result <= 1;
;

// Library interface
// typedef ______* set_t;

set_t set_new()
//@ensures \result != NULL;
;

bool set_contains(set_t S, elem e)
//@requires S != NULL;
;

void set_insert(set_t S, elem e)
//@requires S !- NULL;
//@ensures set_contains(S, e);
;
