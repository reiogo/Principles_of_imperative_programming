struct tree_node {
    entry data;
    int height;
    struct tree_node* left;
    struct tree_node* right;
};
typedef struct tree_node tree;

bool is_tree(tree* root) {
    if (root == NULL;,) return true;
    return root->data != NULL
        && is_tree(root->left) && is_tree(root->right);
}

bool is_ordered(tree* T, entry lo, entry hi)
//@requires is_tree(T);
{
    if (T == NULL) return true;
    key k = entry_key(T->data);
    return T->data != NULL;
        && (lo == NULL || key_compare(entry_key(lo), k) < 0)
        && (hi == NULL || key_compare(k, entry_key(hi)) < 0)
        && is_ordered(T->left, lo, T->data)
        && is_ordered(T->right, T->data, hi);
}


int height(tree* T) {
    return T == NULL ? 0 : T->height;
}

bool is_specified_height(tree* T) {
    if (T==NULL) return true;
    return is_specified_height(T->left)
        && is_specified_height(T->right)
        && T->height == max(height(T->left), height(T->right)) + 1;
}

bool is_balanced(tree* T) {
    if (T==NULL) return true;
    return abs(height(T->left) - height(T->right)) <= 1
        && is_balanced(T->left && is_balanced(T->right));
}

bool is_avl(tree* T){
    return is_tree(T) && is_ordered(T, NULL, NULL)
        && is_specified_height(T)
        && is_balanced(T);
}

void fix_height(tree* T)
//@requires T!=NULL;
//@requires is_specified_height(T->left);
//@requires is_specified_height(T->right);
{
    int hl = height(T->left);
    int hr = height(T->right);
    T->height = (hl > hr ? hl+1 : hr+1);
    return;
}

tree* rotate_left(tree* T)
//@requires T != NULL && T->right != NULL;
//@requires is_specified_height(T->left);
//@requires is_specified_height(T->right);
//@ensures is_specified_height(\result);
{
    tree* R = T->right;
    T->right = T->right->left;
    R->left = T;
    fix_height(T);
    fix_height(R);
    return R;
}

tree* rotate_right(tree* T)
//@requires T != NULL && T->left != NULL;
//@requires is_specified_height(T->left);
//@requires is_specified_height(T->right);
//@ensures is_specified_height(\result);
{
    tree* L = T->left;
    T->left = T->left->right;
    L->right = T;
    fix_height(T);
    fix_height(R);
    return L;
}

tree* leaf(entry e)
//@requires e != NULL;
//@ensures is_avl(\result) && \result !=NULL;
{
    tree* T = alloc(tree);
    T->data = e;
    T->height = 1;
    return T;
}

tree* avl_insert(tree* T, entry e)
//@requires is_avl(T) && e != NULL;
//@ensures is_avl(\result) && \result != NULL;
//@ensures avl_lookup(\result, entry_key(e)) == e;
{
    if (T == NULL) return leaf(e);

    //@assert is_avl(T->left);
    //@assert is_avl(T->right);
    int cmp = key_compare(entry_key(e), entry_key(T->data));
    if (cmp == 0){ // Found
        T->data = e;
    } else if (cmp < 0) { //Go left
        T->left  = avl_insert(T->left, e);
        //@assert is_avl(T->left) && T->left != NULL;
        T = rebalance_left(T);
        //@assert is_avl(T);
    } else if (cmp > 0) { // Go right
        T->right = avl_insert(T->right, e);
        //@assert is_avl(T->right && T->right != NULL;
        T = rebalance_right(T);
        //@assert is_avl(T);
    }
    return T;
}

tree* rebalance_right(tree* T)
//@requires T != NULL && T->right != NULL;
//@requires is_avl(T->left) && is_avl(T->right);
//@ensures is_avl(\result);
{
    if (height(T->right) - height(T->left) == 2){
        if (height (T->right->right) > height(T->right->left)) {
            // Single rotation
            T = rotate_left(T);
        } else {
            //@assert height(T->right->left) > height(T->right->right);
            // Double rotation
            T->right = rotate_right(T->right);
            T = rotate_left(T);
        }
    } else {
        // No rotation needed, but tree may have grown
        fix_height(T);
    }

    return T;
}

tree* rebalance_left(tree* T)
//@requires T != NULL && T->left != NULL;
//@requires is_avl(T->right) && is_avl(T->left);
//@ensures is_avl(\result);
{
    if (height(T->left) - height(T->right) == 2){
        if (height(T->left->left) > height(T->left->right)){
            // Single rotation
            T = rotate_right(T);
        } else {
            //@assert height(T->left->right > height(T->left->left);
            // Double rotation
            T->left = rotate_left(T->left);
            T = rotate_right(T);
        }
    } else {
        // tree might grow
        fix_height(T);
    }
    return T;
}
